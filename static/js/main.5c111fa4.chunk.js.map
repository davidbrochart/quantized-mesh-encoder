{"version":3,"sources":["tile-layer/tile-2d-header.js","tile-layer/tile-2d-traversal.js","tile-layer/utils.js","tile-layer/tileset-2d.js","tile-layer/tile-layer.js","quantized-mesh-layer.js","info-box.js","App.js","serviceWorker.js","index.js"],"names":["Tile2DHeader","x","y","z","onTileLoad","onTileError","this","isVisible","isSelected","parent","children","content","_isLoaded","_isCancelled","getTileData","requestScheduler","bbox","scheduleRequest","tile","requestToken","tileData","error","done","_loader","_loadData","result","byteLength","Number","isFinite","log","OSMNode","params","viewport","cullingVolume","elevationBounds","minZ","maxZ","offset","boundingVolume","getBoundingVolume","computeVisibility","childVisible","distance","distanceTo","cameraPosition","scale","height","Math","floor","log2","selected","update","push","_children","node","getSelected","zRange","worldOffset","extent","pow","originX","originY","AxisAlignedBoundingBox","DEFAULT_EXTENT","Infinity","urlType","type","value","validate","Array","isArray","every","url","equals","value1","value2","len","length","i","getTileIndex","getScale","osmTile2lngLat","lng","n","PI","atan","exp","tile2XY","tileToBoundingBox","isGeospatial","west","north","east","south","left","top","right","bottom","getIdentityTileIndices","bounds","bounds0","getBounds","bounds1","min","max","getBoundingBox","minX","minY","maxX","maxY","indices","getTileIndices","maxZoom","minZoom","tileSize","round","zoom","planes","Object","values","getFrustumPlanes","map","normal","Plane","clone","negate","CullingVolume","unitsPerMeter","distanceScales","elevationMin","elevationMax","pitch","root","traversalParams","subViewports","getOSMTileIndices","Tileset2D","opts","_getTileData","maxCacheByteSize","_cacheByteSize","_resizeCache","_requestScheduler","RequestScheduler","maxRequests","throttleRequests","_cache","Map","_tiles","_dirty","_viewport","_selectedTiles","_frameNumber","setOptions","assign","_maxZoom","_minZoom","ceil","tileIndices","index","_getTile","_rebuildTree","changed","updateTileStates","tileIndex","_updateTileStates","selectedTiles","Boolean","state","_getNearestAncestor","refinementStrategy","getPlaceholderInAncestors","needsPlaceholder","getPlaceholderInChildren","maxCacheSize","size","tileId","delete","from","sort","t1","t2","create","get","getTileMetadata","loadData","set","isCancelled","getParentIndex","isLoaded","t","TILE_STATE_VISIBLE","child","defaultProps","data","dataComparator","renderSubLayers","props","GeoJsonLayer","compare","optional","onViewportLoad","err","console","TileLayer","tiles","changeFlags","somethingChanged","oldProps","context","tileset","dataChanged","updateTriggersChanged","all","bind","_onTileLoad","_onTileError","setState","propsChanged","forEach","layers","_updateTileset","frameNumber","loadingStateChanged","tilesetChanged","getCurrentLayer","setNeedsUpdate","layer","template","properties","fetch","abs","replace","_","property","info","sourceLayer","visible","highlightedObjectIndex","getHighlightedObjectIndex","id","_offset","flatten","CompositeLayer","layerName","DUMMY_DATA","getMeshMaxError","toFixed","quantizedMeshUrl","mosaicUrl","meshMaxError","searchParams","URLSearchParams","mesh_max_error","toString","QuantizedMeshTerrainLayer","a","terrainUrl","load","QuantizedMeshLoader","SimpleMeshLayer","mesh","getPolygonOffset","coordinateSystem","COORDINATE_SYSTEM","CARTESIAN","modelMatrix","getModelMatrix","getPosition","d","getColor","worldScale","xScale","yScale","xOffset","yOffset","Matrix4","translate","InfoBox","Container","style","position","width","maxWidth","padding","maxHeight","zIndex","backgroundColor","pointerEvents","overflowY","overflow","Header","as","target","rel","href","Icon","name","INITIAL_VIEW_STATE","latitude","longitude","bearing","maxPitch","App","viewState","ranges","arr","header","boundingBox","bound","initialViewState","onViewStateChange","controller","touchRotate","React","Component","document","body","margin","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.5c111fa4.chunk.js","sourcesContent":["import {log} from '@deck.gl/core';\n\nexport default class Tile2DHeader {\n  constructor({x, y, z, onTileLoad, onTileError}) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.isVisible = false;\n    this.isSelected = false;\n    this.parent = null;\n    this.children = [];\n\n    this.content = null;\n    this._isLoaded = false;\n    this._isCancelled = false;\n\n    this.onTileLoad = onTileLoad;\n    this.onTileError = onTileError;\n  }\n\n  get data() {\n    return this._isLoaded ? this.content : this._loader;\n  }\n\n  get isLoaded() {\n    return this._isLoaded;\n  }\n\n  get isCancelled() {\n    return this._isCancelled;\n  }\n\n  get byteLength() {\n    const result = this.content ? this.content.byteLength : 0;\n    if (!Number.isFinite(result)) {\n      log.error('byteLength not defined in tile data')();\n    }\n    return result;\n  }\n\n  async _loadData(getTileData, requestScheduler) {\n    const {x, y, z, bbox} = this;\n\n    const requestToken = await requestScheduler.scheduleRequest(this, tile => {\n      return tile.isSelected;\n    });\n\n    if (!requestToken) {\n      this._isCancelled = true;\n      return;\n    }\n\n    this._isCancelled = false;\n    let tileData;\n    let error;\n    try {\n      tileData = await getTileData({x, y, z, bbox});\n    } catch (err) {\n      error = err || true;\n    } finally {\n      requestToken.done();\n      this._isLoaded = true;\n    }\n\n    if (error) {\n      this.onTileError(error, this);\n    } else {\n      this.content = tileData;\n      this.onTileLoad(this);\n    }\n  }\n\n  loadData(getTileData, requestScheduler) {\n    if (!getTileData) {\n      return;\n    }\n\n    this._loader = this._loadData(getTileData, requestScheduler);\n  }\n}\n","/* eslint-disable complexity */\nimport {CullingVolume, Plane, AxisAlignedBoundingBox} from '@math.gl/culling';\n\nconst TILE_SIZE = 512;\n// number of world copies to check\nconst MAX_MAPS = 3;\n\nclass OSMNode {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  get children() {\n    if (!this._children) {\n      const x = this.x * 2;\n      const y = this.y * 2;\n      const z = this.z + 1;\n      this._children = [\n        new OSMNode(x, y, z),\n        new OSMNode(x, y + 1, z),\n        new OSMNode(x + 1, y, z),\n        new OSMNode(x + 1, y + 1, z)\n      ];\n    }\n    return this._children;\n  }\n\n  update(params) {\n    const {viewport, cullingVolume, elevationBounds, minZ, maxZ, offset} = params;\n    const boundingVolume = this.getBoundingVolume(elevationBounds, offset);\n\n    // First, check if this tile is visible\n    const isInside = cullingVolume.computeVisibility(boundingVolume);\n    if (isInside < 0) {\n      return false;\n    }\n\n    // Avoid loading overlapping tiles - if a descendant is requested, do not request the ancester\n    if (!this.childVisible) {\n      let {z} = this;\n      if (z < maxZ && z >= minZ) {\n        // Adjust LOD\n        // If the tile is far enough from the camera, accept a lower zoom level\n        const distance =\n          (boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale) / viewport.height;\n        z += Math.floor(Math.log2(distance));\n      }\n      if (z >= maxZ) {\n        // LOD is acceptable\n        this.selected = true;\n        return true;\n      }\n    }\n\n    // LOD is not enough, recursively test child tiles\n    this.selected = false;\n    this.childVisible = true;\n    for (const child of this.children) {\n      child.update(params);\n    }\n    return true;\n  }\n\n  getSelected(result = []) {\n    if (this.selected) {\n      result.push(this);\n    }\n    if (this._children) {\n      for (const node of this._children) {\n        node.getSelected(result);\n      }\n    }\n    return result;\n  }\n\n  getBoundingVolume(zRange, worldOffset) {\n    const scale = Math.pow(2, this.z);\n    const extent = TILE_SIZE / scale;\n    const originX = this.x * extent + worldOffset * TILE_SIZE;\n    // deck's common space is y-flipped\n    const originY = TILE_SIZE - (this.y + 1) * extent;\n\n    return new AxisAlignedBoundingBox(\n      [originX, originY, zRange[0]],\n      [originX + extent, originY + extent, zRange[1]]\n    );\n  }\n}\n\nexport function getOSMTileIndices(viewport, maxZ, zRange) {\n  // Get the culling volume of the current camera\n  const planes = Object.values(viewport.getFrustumPlanes()).map(\n    ({normal, distance}) => new Plane(normal.clone().negate(), distance)\n  );\n  const cullingVolume = new CullingVolume(planes);\n\n  // Project zRange from meters to common space\n  const unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];\n  const elevationMin = (zRange && zRange[0] * unitsPerMeter) || 0;\n  const elevationMax = (zRange && zRange[1] * unitsPerMeter) || 0;\n\n  // Always load at the current zoom level if pitch is small\n  const minZ = viewport.pitch <= 60 ? maxZ : 0;\n\n  const root = new OSMNode(0, 0, 0);\n  const traversalParams = {\n    viewport,\n    cullingVolume,\n    elevationBounds: [elevationMin, elevationMax],\n    minZ,\n    maxZ,\n    // num. of worlds from the center. For repeated maps\n    offset: 0\n  };\n\n  root.update(traversalParams);\n\n  if (viewport.subViewports && viewport.subViewports.length > 1) {\n    // Check worlds in repeated maps\n    traversalParams.offset = -1;\n    while (root.update(traversalParams)) {\n      if (--traversalParams.offset < -MAX_MAPS) {\n        break;\n      }\n    }\n    traversalParams.offset = 1;\n    while (root.update(traversalParams)) {\n      if (++traversalParams.offset > MAX_MAPS) {\n        break;\n      }\n    }\n  }\n\n  return root.getSelected();\n}\n","import {getOSMTileIndices} from './tile-2d-traversal';\n\nconst TILE_SIZE = 512;\nconst DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];\n\nexport const urlType = {\n  type: 'url',\n  value: '',\n  validate: value =>\n    typeof value === 'string' ||\n    (Array.isArray(value) && value.every(url => typeof url === 'string')),\n  equals: (value1, value2) => {\n    if (value1 === value2) {\n      return true;\n    }\n    if (!Array.isArray(value1) || !Array.isArray(value2)) {\n      return false;\n    }\n    const len = value1.length;\n    if (len !== value2.length) {\n      return false;\n    }\n    for (let i = 0; i < len; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n\nexport function getURLFromTemplate(template, properties) {\n  if (!template || !template.length) {\n    return null;\n  }\n  if (Array.isArray(template)) {\n    const index = Math.abs(properties.x + properties.y) % template.length;\n    template = template[index];\n  }\n  return template.replace\n    ? template.replace(/\\{ *([\\w_-]+) *\\}/g, (_, property) => properties[property])\n    : null;\n}\n\n/**\n * gets the bounding box of a viewport\n */\nfunction getBoundingBox(viewport, zRange, extent) {\n  let bounds;\n  if (zRange && zRange.length === 2) {\n    const [minZ, maxZ] = zRange;\n    const bounds0 = viewport.getBounds({z: minZ});\n    const bounds1 = viewport.getBounds({z: maxZ});\n    bounds = [\n      Math.min(bounds0[0], bounds1[0]),\n      Math.min(bounds0[1], bounds1[1]),\n      Math.max(bounds0[2], bounds1[2]),\n      Math.max(bounds0[3], bounds1[3])\n    ];\n  } else {\n    bounds = viewport.getBounds();\n  }\n  return [\n    Math.max(bounds[0], extent[0]),\n    Math.max(bounds[1], extent[1]),\n    Math.min(bounds[2], extent[2]),\n    Math.min(bounds[3], extent[3])\n  ];\n}\n\nfunction getTileIndex([x, y], scale) {\n  return [(x * scale) / TILE_SIZE, (y * scale) / TILE_SIZE];\n}\n\nfunction getScale(z) {\n  return Math.pow(2, z);\n}\n\n// https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Lon..2Flat._to_tile_numbers_2\nfunction osmTile2lngLat(x, y, z) {\n  const scale = getScale(z);\n  const lng = (x / scale) * 360 - 180;\n  const n = Math.PI - (2 * Math.PI * y) / scale;\n  const lat = (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));\n  return [lng, lat];\n}\n\nfunction tile2XY(x, y, z) {\n  const scale = getScale(z);\n  return [(x / scale) * TILE_SIZE, (y / scale) * TILE_SIZE];\n}\n\nexport function tileToBoundingBox(viewport, x, y, z) {\n  if (viewport.isGeospatial) {\n    const [west, north] = osmTile2lngLat(x, y, z);\n    const [east, south] = osmTile2lngLat(x + 1, y + 1, z);\n    return {west, north, east, south};\n  }\n  const [left, top] = tile2XY(x, y, z);\n  const [right, bottom] = tile2XY(x + 1, y + 1, z);\n  return {left, top, right, bottom};\n}\n\nfunction getIdentityTileIndices(viewport, z, extent) {\n  const bbox = getBoundingBox(viewport, null, extent);\n  const scale = getScale(z);\n\n  const [minX, minY] = getTileIndex([bbox[0], bbox[1]], scale);\n  const [maxX, maxY] = getTileIndex([bbox[2], bbox[3]], scale);\n  const indices = [];\n\n  /*\n      |  TILE  |  TILE  |  TILE  |\n        |(minX)            |(maxX)\n   */\n  for (let x = Math.floor(minX); x < maxX; x++) {\n    for (let y = Math.floor(minY); y < maxY; y++) {\n      indices.push({x, y, z});\n    }\n  }\n  return indices;\n}\n\n/**\n * Returns all tile indices in the current viewport. If the current zoom level is smaller\n * than minZoom, return an empty array. If the current zoom level is greater than maxZoom,\n * return tiles that are on maxZoom.\n */\nexport function getTileIndices({viewport, maxZoom, minZoom, zRange, extent, tileSize = TILE_SIZE}) {\n  let z = Math.round(viewport.zoom + Math.log2(TILE_SIZE / tileSize));\n  if (Number.isFinite(minZoom) && z < minZoom) {\n    if (!extent) {\n      return [];\n    }\n    z = minZoom;\n  }\n  if (Number.isFinite(maxZoom) && z > maxZoom) {\n    z = maxZoom;\n  }\n  return viewport.isGeospatial\n    ? getOSMTileIndices(viewport, z, zRange, extent || DEFAULT_EXTENT)\n    : getIdentityTileIndices(viewport, z, extent || DEFAULT_EXTENT);\n}\n","import Tile2DHeader from './tile-2d-header';\nimport {getTileIndices, tileToBoundingBox} from './utils';\nimport {RequestScheduler} from '@loaders.gl/loader-utils';\n\nconst TILE_STATE_UNKNOWN = 0;\nconst TILE_STATE_VISIBLE = 1;\n/*\n   show cached parent tile if children are loading\n   +-----------+       +-----+            +-----+-----+\n   |           |       |     |            |     |     |\n   |           |       |     |            |     |     |\n   |           |  -->  +-----+-----+  ->  +-----+-----+\n   |           |             |     |      |     |     |\n   |           |             |     |      |     |     |\n   +-----------+             +-----+      +-----+-----+\n\n   show cached children tiles when parent is loading\n   +-------+----       +------------\n   |       |           |\n   |       |           |\n   |       |           |\n   +-------+----  -->  |\n   |       |           |\n */\nconst TILE_STATE_PLACEHOLDER = 3;\nconst TILE_STATE_HIDDEN = 4;\n// tiles that should be displayed in the current viewport\nconst TILE_STATE_SELECTED = 5;\n\nexport const STRATEGY_NEVER = 'never';\nexport const STRATEGY_REPLACE = 'no-overlap';\nexport const STRATEGY_DEFAULT = 'best-available';\n\nconst DEFAULT_CACHE_SCALE = 5;\n\n/**\n * Manages loading and purging of tiles data. This class caches recently visited tiles\n * and only create new tiles if they are present.\n */\n\nexport default class Tileset2D {\n  /**\n   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.\n   * Cache size defaults to 5 * number of tiles in the current viewport\n   */\n  constructor(opts) {\n    this.opts = opts;\n    this._getTileData = opts.getTileData;\n\n    this.onTileError = opts.onTileError;\n    this.onTileLoad = tile => {\n      opts.onTileLoad(tile);\n      if (this.opts.maxCacheByteSize) {\n        this._cacheByteSize += tile.byteLength;\n        this._resizeCache();\n      }\n    };\n\n    this._requestScheduler = new RequestScheduler({\n      maxRequests: opts.maxRequests,\n      throttleRequests: opts.throttleRequests && opts.maxRequests > 0\n    });\n\n    // Maps tile id in string {z}-{x}-{y} to a Tile object\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n\n    // Cache the last processed viewport\n    this._viewport = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n\n    this.setOptions(opts);\n  }\n\n  /* Public API */\n  get tiles() {\n    return this._tiles;\n  }\n\n  get selectedTiles() {\n    return this._selectedTiles;\n  }\n\n  get isLoaded() {\n    return this._selectedTiles.every(tile => tile.isLoaded);\n  }\n\n  setOptions(opts) {\n    Object.assign(this.opts, opts);\n    if (Number.isFinite(opts.maxZoom)) {\n      this._maxZoom = Math.floor(opts.maxZoom);\n    }\n    if (Number.isFinite(opts.minZoom)) {\n      this._minZoom = Math.ceil(opts.minZoom);\n    }\n  }\n\n  /**\n   * Update the cache with the given viewport and triggers callback onUpdate.\n   * @param {*} viewport\n   * @param {*} onUpdate\n   */\n  update(viewport, {zRange} = {}) {\n    if (!viewport.equals(this._viewport)) {\n      this._viewport = viewport;\n      const tileIndices = this.getTileIndices({\n        viewport,\n        maxZoom: this._maxZoom,\n        minZoom: this._minZoom,\n        zRange\n      });\n      this._selectedTiles = tileIndices.map(index => this._getTile(index, true));\n\n      if (this._dirty) {\n        // Some new tiles are added\n        this._rebuildTree();\n      }\n    }\n\n    // Update tile states\n    const changed = this.updateTileStates();\n\n    if (this._dirty) {\n      // cache size is either the user defined maxSize or 5 * number of current tiles in the viewport.\n      this._resizeCache();\n    }\n\n    if (changed) {\n      this._frameNumber++;\n    }\n    return this._frameNumber;\n  }\n\n  /* Public interface for subclassing */\n\n  // Returns array of {x, y, z}\n  getTileIndices({viewport, maxZoom, minZoom, zRange}) {\n    const {tileSize, extent} = this.opts;\n    return getTileIndices({viewport, maxZoom, minZoom, zRange, tileSize, extent});\n  }\n\n  // Add custom metadata to tiles\n  getTileMetadata({x, y, z}) {\n    return {bbox: tileToBoundingBox(this._viewport, x, y, z)};\n  }\n\n  // Returns {x, y, z} of the parent tile\n  getParentIndex(tileIndex) {\n    // Perf: mutate the input object to avoid GC\n    tileIndex.x = Math.floor(tileIndex.x / 2);\n    tileIndex.y = Math.floor(tileIndex.y / 2);\n    tileIndex.z -= 1;\n    return tileIndex;\n  }\n\n  // Returns true if any tile's visibility changed\n  updateTileStates() {\n    this._updateTileStates(this.selectedTiles);\n\n    let changed = false;\n    for (const tile of this._cache.values()) {\n      const isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n      if (tile.isVisible !== isVisible) {\n        changed = true;\n        tile.isVisible = isVisible;\n      }\n\n      // isSelected used in request scheduler\n      tile.isSelected = tile.state === TILE_STATE_SELECTED;\n    }\n\n    return changed;\n  }\n\n  /* Private methods */\n\n  // This needs to be called every time some tiles have been added/removed from cache\n  _rebuildTree() {\n    const {_cache} = this;\n\n    // Reset states\n    for (const tile of _cache.values()) {\n      tile.parent = null;\n      tile.children.length = 0;\n    }\n\n    // Rebuild tree\n    for (const tile of _cache.values()) {\n      const parent = this._getNearestAncestor(tile.x, tile.y, tile.z);\n      tile.parent = parent;\n      if (parent) {\n        parent.children.push(tile);\n      }\n    }\n  }\n\n  // A selected tile is always visible.\n  // Never show two overlapping tiles.\n  // If a selected tile is loading, try showing a cached ancester with the closest z\n  // If a selected tile is loading, and no ancester is shown - try showing cached\n  // descendants with the closest z\n  _updateTileStates(selectedTiles) {\n    const {_cache} = this;\n    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n\n    // Reset states\n    for (const tile of _cache.values()) {\n      tile.state = TILE_STATE_UNKNOWN;\n    }\n\n    // For all the selected && pending tiles:\n    // - pick the closest ancestor as placeholder\n    // - if no ancestor is visible, pick the closest children as placeholder\n    for (const tile of selectedTiles) {\n      tile.state = TILE_STATE_SELECTED;\n    }\n\n    if (refinementStrategy === STRATEGY_NEVER) {\n      return;\n    }\n    for (const tile of selectedTiles) {\n      getPlaceholderInAncestors(tile, refinementStrategy);\n    }\n    for (const tile of selectedTiles) {\n      if (needsPlaceholder(tile)) {\n        getPlaceholderInChildren(tile);\n      }\n    }\n  }\n\n  /**\n   * Clear tiles that are not visible when the cache is full\n   */\n  /* eslint-disable complexity */\n  _resizeCache() {\n    const {_cache, opts} = this;\n\n    const maxCacheSize =\n      opts.maxCacheSize ||\n      (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n    const maxCacheByteSize = opts.maxCacheByteSize || Infinity;\n\n    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n\n    if (overflown) {\n      for (const [tileId, tile] of _cache) {\n        if (!tile.isVisible) {\n          // delete tile\n          this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;\n          _cache.delete(tileId);\n        }\n        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n          break;\n        }\n      }\n      this._rebuildTree();\n      this._dirty = true;\n    }\n    if (this._dirty) {\n      this._tiles = Array.from(this._cache.values())\n        // sort by zoom level so that smaller tiles are displayed on top\n        .sort((t1, t2) => t1.z - t2.z);\n\n      this._dirty = false;\n    }\n  }\n  /* eslint-enable complexity */\n\n  _getTile({x, y, z}, create) {\n    const tileId = `${x},${y},${z}`;\n    let tile = this._cache.get(tileId);\n\n    if (!tile && create) {\n      tile = new Tile2DHeader({\n        x,\n        y,\n        z,\n        onTileLoad: this.onTileLoad,\n        onTileError: this.onTileError\n      });\n      Object.assign(tile, this.getTileMetadata(tile));\n      tile.loadData(this._getTileData, this._requestScheduler);\n      this._cache.set(tileId, tile);\n      this._dirty = true;\n    } else if (tile && tile.isCancelled) {\n      tile.loadData(this._getTileData, this._requestScheduler);\n    }\n\n    return tile;\n  }\n\n  _getNearestAncestor(x, y, z) {\n    const {_minZoom = 0} = this;\n    let index = {x, y, z};\n\n    while (index.z > _minZoom) {\n      index = this.getParentIndex(index);\n      const parent = this._getTile(index);\n      if (parent) {\n        return parent;\n      }\n    }\n    return null;\n  }\n}\n\n// A selected tile needs placeholder from its children if\n// - it is not loaded\n// - none of its ancestors is visible and loaded\nfunction needsPlaceholder(tile) {\n  let t = tile;\n  while (t) {\n    if (t.state & (TILE_STATE_VISIBLE === 0)) {\n      return true;\n    }\n    if (t.isLoaded) {\n      return false;\n    }\n    t = t.parent;\n  }\n  return true;\n}\n\nfunction getPlaceholderInAncestors(tile, refinementStrategy) {\n  let parent;\n  let state = TILE_STATE_PLACEHOLDER;\n  while ((parent = tile.parent)) {\n    if (tile.isLoaded) {\n      // If a tile is loaded, mark all its ancestors as hidden\n      state = TILE_STATE_HIDDEN;\n      if (refinementStrategy === STRATEGY_DEFAULT) {\n        return;\n      }\n    }\n    parent.state = Math.max(parent.state, state);\n    tile = parent;\n  }\n}\n\n// Recursively set children as placeholder\nfunction getPlaceholderInChildren(tile) {\n  for (const child of tile.children) {\n    child.state = Math.max(child.state, TILE_STATE_PLACEHOLDER);\n    if (!child.isLoaded) {\n      getPlaceholderInChildren(child);\n    }\n  }\n}\n","import {CompositeLayer, _flatten as flatten} from '@deck.gl/core';\nimport {GeoJsonLayer} from '@deck.gl/layers';\n\nimport Tileset2D, {STRATEGY_DEFAULT} from './tileset-2d';\nimport {urlType, getURLFromTemplate} from './utils';\n\nconst defaultProps = {\n  data: [],\n  dataComparator: urlType.equals,\n  renderSubLayers: {type: 'function', value: props => new GeoJsonLayer(props), compare: false},\n  getTileData: {type: 'function', optional: true, value: null, compare: false},\n  // TODO - change to onViewportLoad to align with Tile3DLayer\n  onViewportLoad: {type: 'function', optional: true, value: null, compare: false},\n  onTileLoad: {type: 'function', value: tile => {}, compare: false},\n  // eslint-disable-next-line\n  onTileError: {type: 'function', value: err => console.error(err), compare: false},\n  extent: {type: 'array', optional: true, value: null, compare: true},\n  tileSize: 512,\n  maxZoom: null,\n  minZoom: 0,\n  maxCacheSize: null,\n  maxCacheByteSize: null,\n  refinementStrategy: STRATEGY_DEFAULT,\n  zRange: null,\n  throttleRequests: true,\n  maxRequests: 8\n};\n\nexport default class TileLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      tiles: [],\n      isLoaded: false\n    };\n  }\n\n  get isLoaded() {\n    const {tileset} = this.state;\n    return tileset.selectedTiles.every(\n      tile => tile.layers && tile.layers.every(layer => layer.isLoaded)\n    );\n  }\n\n  shouldUpdateState({changeFlags}) {\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({props, oldProps, context, changeFlags}) {\n    let {tileset} = this.state;\n    const createTileCache =\n      !tileset ||\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData));\n\n    if (createTileCache) {\n      const {\n        maxZoom,\n        minZoom,\n        tileSize,\n        maxCacheSize,\n        maxCacheByteSize,\n        refinementStrategy,\n        extent,\n        throttleRequests,\n        maxRequests\n      } = props;\n      tileset = new Tileset2D({\n        getTileData: this.getTileData.bind(this),\n        maxCacheSize,\n        maxCacheByteSize,\n        maxZoom,\n        minZoom,\n        tileSize,\n        refinementStrategy,\n        extent,\n        onTileLoad: this._onTileLoad.bind(this),\n        onTileError: this._onTileError.bind(this),\n        throttleRequests,\n        maxRequests\n      });\n      this.setState({tileset});\n    } else if (changeFlags.propsChanged || changeFlags.updateTriggersChanged) {\n      tileset.setOptions(props);\n      // if any props changed, delete the cached layers\n      this.state.tileset.tiles.forEach(tile => {\n        tile.layers = null;\n      });\n    }\n\n    this._updateTileset();\n  }\n\n  _updateTileset() {\n    const {tileset} = this.state;\n    const {onViewportLoad, zRange} = this.props;\n    const frameNumber = tileset.update(this.context.viewport, {zRange});\n    const {isLoaded} = tileset;\n\n    const loadingStateChanged = this.state.isLoaded !== isLoaded;\n    const tilesetChanged = this.state.frameNumber !== frameNumber;\n\n    if (isLoaded && onViewportLoad && (loadingStateChanged || tilesetChanged)) {\n      onViewportLoad(tileset.selectedTiles.map(tile => tile.data));\n    }\n\n    if (tilesetChanged) {\n      // Save the tileset frame number - trigger a rerender\n      this.setState({frameNumber});\n    }\n    // Save the loaded state - should not trigger a rerender\n    this.state.isLoaded = isLoaded;\n  }\n\n  _onTileLoad(tile) {\n    const layer = this.getCurrentLayer();\n    layer.props.onTileLoad(tile);\n\n    if (tile.isVisible) {\n      this.setNeedsUpdate();\n    }\n  }\n\n  _onTileError(error, tile) {\n    const layer = this.getCurrentLayer();\n    layer.props.onTileError(error);\n    // errorred tiles should not block rendering, are considered \"loaded\" with empty data\n    layer._updateTileset();\n\n    if (tile.isVisible) {\n      this.setNeedsUpdate();\n    }\n  }\n\n  // Methods for subclass to override\n\n  getTileData(tile) {\n    const {getTileData, fetch, data} = this.props;\n\n    tile.url = getURLFromTemplate(data, tile);\n\n    if (getTileData) {\n      return getTileData(tile);\n    }\n    if (tile.url) {\n      return fetch(tile.url, {layer: this});\n    }\n    return null;\n  }\n\n  renderSubLayers(props) {\n    return this.props.renderSubLayers(props);\n  }\n\n  getHighlightedObjectIndex() {\n    return -1;\n  }\n\n  getPickingInfo({info, sourceLayer}) {\n    info.sourceLayer = sourceLayer;\n    info.tile = sourceLayer.props.tile;\n    return info;\n  }\n\n  renderLayers() {\n    const {visible} = this.props;\n    return this.state.tileset.tiles.map(tile => {\n      // For a tile to be visible:\n      // - parent layer must be visible\n      // - tile must be visible in the current viewport\n      const isVisible = visible && tile.isVisible;\n      const highlightedObjectIndex = this.getHighlightedObjectIndex(tile);\n      // cache the rendered layer in the tile\n      if (!tile.isLoaded) {\n        // no op\n      } else if (!tile.layers) {\n        const layers = this.renderSubLayers(\n          Object.assign({}, this.props, {\n            id: `${this.id}-${tile.x}-${tile.y}-${tile.z}`,\n            data: tile.data,\n            visible: isVisible,\n            _offset: 0,\n            tile,\n            highlightedObjectIndex\n          })\n        );\n        tile.layers = flatten(layers, Boolean);\n      } else if (\n        tile.layers[0] &&\n        (tile.layers[0].props.visible !== isVisible ||\n          tile.layers[0].props.highlightedObjectIndex !== highlightedObjectIndex)\n      ) {\n        tile.layers = tile.layers.map(layer =>\n          layer.clone({visible: isVisible, highlightedObjectIndex})\n        );\n      }\n      return tile.layers;\n    });\n  }\n}\n\nTileLayer.layerName = 'TileLayer';\nTileLayer.defaultProps = defaultProps;\n","// import { TileLayer } from \"@deck.gl/geo-layers\";\nimport { SimpleMeshLayer } from \"@deck.gl/mesh-layers\";\nimport { COORDINATE_SYSTEM } from \"@deck.gl/core\";\nimport { load } from \"@loaders.gl/core\";\nimport { QuantizedMeshLoader } from \"@loaders.gl/terrain\";\nimport { Matrix4 } from \"math.gl\";\n// Temporary until deck.gl 8.2 is released\nimport TileLayer from \"./tile-layer/tile-layer\";\n\nconst DUMMY_DATA = [1];\n\n// Error suggestion from here\n// https://www.linkedin.com/pulse/fast-cesium-terrain-rendering-new-quantized-mesh-output-alvaro-huarte/\nfunction getMeshMaxError(z) {\n  return (77067.34 / (1 << z)).toFixed(2);\n}\n\nfunction quantizedMeshUrl(opts) {\n  const { x, y, z, mosaicUrl = \"terrarium\", meshMaxError = 10 } = opts;\n  const params = {\n    url: mosaicUrl,\n    mesh_max_error: meshMaxError,\n  };\n  const searchParams = new URLSearchParams(params);\n  let baseUrl = `https://us-east-1-lambda.kylebarron.dev/dem/mesh/${z}/${x}/${y}.terrain?`;\n  return baseUrl + searchParams.toString();\n}\n\nexport function QuantizedMeshTerrainLayer(opts) {\n  const { minZoom = 0, maxZoom = 15, onViewportLoad, zRange } = opts || {};\n  return new TileLayer({\n    id: \"quantized-mesh-tile\",\n    minZoom,\n    maxZoom,\n    getTileData,\n    renderSubLayers,\n    onViewportLoad,\n    zRange,\n    refinementStrategy: \"no-overlap\",\n  });\n}\n\nasync function getTileData({ x, y, z }) {\n  const meshMaxError = getMeshMaxError(z);\n  const terrainUrl = quantizedMeshUrl({ x, y, z, meshMaxError });\n  return load(terrainUrl, QuantizedMeshLoader);\n}\n\nfunction renderSubLayers(props) {\n  const { data, tile } = props;\n\n  return [\n    new SimpleMeshLayer(props, {\n      // NOTE: currently you need to set each sublayer id so they don't conflict\n      id: `terrain-simple-mesh-layer-${tile.x}-${tile.y}-${tile.z}`,\n      data: DUMMY_DATA,\n      mesh: data,\n      getPolygonOffset: null,\n      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n      modelMatrix: getModelMatrix(tile),\n      getPosition: (d) => [0, 0, 0],\n      // Color to use if surfaceImage is unavailable\n      getColor: [200, 200, 200],\n      // wireframe: true,\n    }),\n  ];\n}\n\n// From https://github.com/uber/deck.gl/blob/b1901b11cbdcb82b317e1579ff236d1ca1d03ea7/modules/geo-layers/src/mvt-tile-layer/mvt-tile-layer.js#L41-L52\n// Necessary when using COORDINATE_SYSTEM.CARTESIAN with the standard web\n// mercator viewport\nfunction getModelMatrix(tile) {\n  const WORLD_SIZE = 512;\n  const worldScale = Math.pow(2, tile.z);\n\n  const xScale = WORLD_SIZE / worldScale;\n  const yScale = -xScale;\n\n  const xOffset = (WORLD_SIZE * tile.x) / worldScale;\n  const yOffset = WORLD_SIZE * (1 - tile.y / worldScale);\n\n  return new Matrix4()\n    .translate([xOffset, yOffset, 0])\n    .scale([xScale, yScale, 1]);\n}\n","import React from \"react\";\nimport { Header, Container, Icon } from \"semantic-ui-react\";\n\nexport default function InfoBox(props) {\n  return (\n    <Container\n      style={{\n        position: \"absolute\",\n        width: 300,\n        maxWidth: '50%',\n        left: 5,\n        top: 5,\n        padding: 5,\n        maxHeight: \"50%\",\n        zIndex: 1,\n        backgroundColor: \"#fff\",\n        pointerEvents: \"auto\",\n        overflowY: \"auto\",\n        overflow: \"visible\",\n      }}\n    >\n      <Header as=\"h4\">Serverless Quantized Mesh</Header>\n      <p>\n        Uses{\" \"}\n        <a\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          href=\"https://github.com/kylebarron/pymartini\"\n        >\n          <Icon name=\"github\" />\n          <code>pymartini</code>\n        </a>{\" \"}\n        for mesh generation,{\" \"}\n        <a\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          href=\"https://github.com/kylebarron/quantized-mesh-encoder\"\n        >\n          <Icon name=\"github\" />\n          <code>quantized-mesh-encoder</code>\n        </a>{\" \"}\n        for encoding to quantized mesh,{\" \"}\n        <a\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          href=\"https://github.com/kylebarron/dem-tiler\"\n        >\n          <Icon name=\"github\" />\n          <code>dem-tiler</code>\n        </a>{\" \"}\n        for the serverless API, and{\" \"}\n        <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://deck.gl\">\n          <code>deck.gl</code>\n        </a>{\" \"}\n        for rendering. You can also easily overlay a texture source, e.g. Mapbox\n        Satellite tiles, with deck.gl.{\" \"}\n        <a\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          href=\"https://github.com/kylebarron/quantized-mesh-encoder/tree/master/site\"\n        >\n          <Icon name=\"github\" />\n          Example source.\n        </a>\n      </p>\n    </Container>\n  );\n}\n","import React from \"react\";\nimport DeckGL from \"@deck.gl/react\";\nimport { QuantizedMeshTerrainLayer } from \"./quantized-mesh-layer\";\nimport InfoBox from \"./info-box\";\nimport \"./App.css\";\n\nconst INITIAL_VIEW_STATE = {\n  latitude: 36.07091852096502,\n  longitude: -112.00934837595949,\n  bearing: -35.19642857142857,\n  pitch: 60,\n  zoom: 13.574472859832357,\n  maxPitch: 89,\n};\n\nclass App extends React.Component {\n  state = {\n    viewState: INITIAL_VIEW_STATE,\n    zRange: null,\n  };\n\n  // Update zRange of viewport\n  onViewportLoad = (data) => {\n    if (!data || data.length === 0 || data.every((x) => !x)) {\n      return;\n    }\n\n    const { zRange } = this.state;\n    const ranges = data.map((arr) => {\n      const bounds = arr.header.boundingBox;\n      return bounds.map((bound) => bound[2]);\n    });\n    const minZ = Math.min(...ranges.map((x) => x[0]));\n    const maxZ = Math.max(...ranges.map((x) => x[1]));\n\n    if (!zRange || minZ < zRange[0] || maxZ > zRange[1]) {\n      this.setState({ zRange: [minZ, maxZ] });\n    }\n  };\n\n  render() {\n    const { viewState, zRange } = this.state;\n\n    const layers = [\n      QuantizedMeshTerrainLayer({\n        onViewportLoad: this.onViewportLoad,\n        zRange,\n      }),\n    ];\n\n    return (\n      <div>\n        <DeckGL\n          initialViewState={viewState}\n          layers={layers}\n          onViewStateChange={(viewState) => this.setState({ viewState })}\n          controller={{ touchRotate: true }}\n        />\n        <InfoBox />\n      </div>\n    );\n  }\n}\n\nexport default App;\n\ndocument.body.style.margin = 0;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}